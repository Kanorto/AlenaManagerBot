/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/api/v1/events/": {
    /**
     * List Events
     * @description Получить список мероприятий с фильтрами и сортировкой.
     *
     * - **limit**, **offset** — параметры пагинации.
     * - **sort_by** — поле сортировки: `id`, `title`, `start_time`, `duration_minutes`, `max_participants`.
     * - **order** — направление сортировки (`asc`/`desc`).
     * - **is_paid** — фильтр по платности (true/false) или пропущено.
     * - **date_from**, **date_to** — фильтры по дате начала (ISO‑строки).
     */
    get: operations["list_events_api_v1_events__get"];
    /**
     * Create Event
     * @description Create a new event.
     *
     * Requires an administrator (role_id 1 or 2).  Validates the
     * authenticated user's role via the ``require_roles`` dependency.
     * Future iterations should perform additional validation on the
     * event payload.
     */
    post: operations["create_event_api_v1_events__post"];
  };
  "/api/v1/events/{event_id}": {
    /**
     * Get Event
     * @description Retrieve a single event by its ID.
     *
     * In the future, add authentication and permission checks (e.g.,
     * private events visible only to certain users).  Raises 404 if
     * the event is not found.
     */
    get: operations["get_event_api_v1_events__event_id__get"];
    /**
     * Update Event
     * @description Update an existing event.
     *
     * Only administrators (role_id 1 or 2) may modify events.  Partial
     * updates are supported; any unspecified fields remain unchanged.
     */
    put: operations["update_event_api_v1_events__event_id__put"];
    /**
     * Delete Event
     * @description Delete an event (admin only).
     *
     * When deleting an event, related records (bookings, payments, reviews) are
     * removed as part of the ``EventService.delete_event`` implementation.
     * Future versions should consider soft deletion or additional checks
     * before removing events with dependencies.
     */
    delete: operations["delete_event_api_v1_events__event_id__delete"];
  };
  "/api/v1/events/{event_id}/duplicate": {
    /**
     * Duplicate Event
     * @description Duplicate an event with a new start time.
     *
     * Requires administrator privileges (role_id 1 or 2).  The request
     * body must contain the ``start_time`` for the new event.
     */
    post: operations["duplicate_event_api_v1_events__event_id__duplicate_post"];
  };
  "/api/v1/events/{event_id}/participants": {
    /**
     * List Event Participants
     * @description List all bookings (participants) for an event.
     *
     * Only administrators (role_id 1 or 2) can view the full participant list.
     * Future versions may allow event organizers or the event creator to
     * access this information.
     */
    get: operations["list_event_participants_api_v1_events__event_id__participants_get"];
  };
  "/api/v1/users/": {
    /**
     * List Users
     * @description Получить список всех пользователей.
     *
     * Доступно только супер‑администраторам и администраторам.  В дальнейшем
     * будет добавлена пагинация и фильтрация (по активности, статусу блокировки и т.п.).
     */
    get: operations["list_users_api_v1_users__get"];
    /**
     * Register User
     * @description Зарегистрировать нового пользователя.
     *
     * Принимает данные пользователя и возвращает созданную запись.  В
     * будущем здесь будет реализована проверка уникальности e‑mail,
     * хеширование пароля (bcrypt/argon2), подтверждение почты и
     * присвоение роли по умолчанию.  Сейчас данные хранятся в памяти.
     */
    post: operations["register_user_api_v1_users__post"];
  };
  "/api/v1/users/login": {
    /**
     * Login User
     * @description Аутентифицировать пользователя и вернуть токен.
     *
     * На входе ожидаются e‑mail и пароль.  В дальнейшем рекомендуется
     * выделить отдельную схему ``UserLogin`` и добавить refresh‑токены
     * для долгосрочной сессии.  Метод будет проверять хешированный
     * пароль и, возможно, блокировать учётные записи после нескольких
     * неудачных попыток.
     */
    post: operations["login_user_api_v1_users_login_post"];
  };
  "/api/v1/users/social-login": {
    /**
     * Social Login
     * @description Authenticate or register a user via social provider and return a token.
     *
     * This endpoint allows bots or messenger integrations to obtain a JWT
     * without requiring an email/password.  If a user with the given
     * ``social_provider`` and ``social_id`` exists, a new access token is issued.
     * Otherwise a new user is created with role ``user`` (role_id=3) and a
     * token is returned.  The optional ``full_name`` is used only when creating
     * a new user.
     */
    post: operations["social_login_api_v1_users_social_login_post"];
  };
  "/api/v1/users/{user_id}": {
    /**
     * Update User
     * @description Update a user's profile, status or password.
     *
     * Only administrators may update other users.  The body may
     * contain ``full_name``, ``disabled``, ``password``, or ``role_id``.
     * ``role_id`` changes the user's role via RoleService.
     */
    put: operations["update_user_api_v1_users__user_id__put"];
    /**
     * Delete User Endpoint
     * @description Удалить пользователя по ID.
     *
     * Только супер‑администратор или администратор может удалять пользователей и не может удалить
     * самого себя.  Удаление первого созданного пользователя (главного
     * администратора) также запрещено.  После удаления пользователя
     * связанные записи (сообщения, тикеты, бронирования, платежи) будут
     * удалены каскадно.
     */
    delete: operations["delete_user_endpoint_api_v1_users__user_id__delete"];
  };
  "/api/v1/payments/": {
    /**
     * List Payments
     * @description Получить список платежей.
     *
     * Администратор видит все записи, обычный пользователь — только свои.
     * Поддерживаются фильтры ``event_id``, ``provider`` (yookassa/support/cash), ``status``
     * (pending/success), сортировка по ``created_at`` или ``amount`` и
     * пагинация.
     */
    get: operations["list_payments_api_v1_payments__get"];
    /**
     * Create Payment
     * @description Создать новый платёж.
     *
     * Требуется аутентификация.  В будущем будет реализована
     * проверка валидности суммы, интеграция с платежными шлюзами
     * (ЮKassa, Stripe и т.д.), обработка статусов транзакций и
     * связка с конкретным мероприятием или пополнением баланса.
     */
    post: operations["create_payment_api_v1_payments__post"];
  };
  "/api/v1/payments/{payment_id}/confirm": {
    /**
     * Confirm Payment
     * @description Подтвердить платёж (администратор или супер‑администратор).
     *
     * Устанавливает статус ``success`` и отмечает подтверждающего.  Для
     * платного мероприятия также помечает связанные брони как оплаченные.
     */
    post: operations["confirm_payment_api_v1_payments__payment_id__confirm_post"];
  };
  "/api/v1/payments/{payment_id}": {
    /**
     * Delete Payment
     * @description Удалить платёж.
     *
     * Удаление платежей доступно только супер‑администраторам и администраторам.  При
     * необходимости следует запретить удаление подтверждённых платежей;
     * текущая реализация удаляет любую запись.  Возвращает 204 при
     * успешном удалении.
     */
    delete: operations["delete_payment_api_v1_payments__payment_id__delete"];
  };
  "/api/v1/payments/yookassa/callback": {
    /**
     * Yookassa Callback
     * @description Обработать callback от ЮKassa.
     *
     * В продуктивной среде ЮKassa отправляет уведомления о статусе
     * платежа.  Здесь представлен только пример структуры: поле
     * ``object.id`` должно содержать ``external_id`` платежа.  На
     * основе этого id в базе обновляется статус платежа.  Отсутствие
     * реальных HTTP‑запросов означает, что эта функция не будет
     * вызываться автоматически в данной среде.
     */
    post: operations["yookassa_callback_api_v1_payments_yookassa_callback_post"];
  };
  "/api/v1/events/{event_id}/bookings": {
    /**
     * List Event Bookings
     * @description Получить список бронирований для мероприятия.
     *
     * Поддерживает сортировку по ``created_at``, ``user_id``, ``is_paid`` или
     * ``is_attended``, направление сортировки, а также пагинацию.
     * Доступна только супер‑администраторам и администраторам.
     */
    get: operations["list_event_bookings_api_v1_events__event_id__bookings_get"];
    /**
     * Create Booking
     * @description Создать бронь на мероприятие.
     *
     * Если свободных мест нет, пользователь будет помещён в лист ожидания,
     * и возвращается HTTP 400 с описанием.  В противном случае
     * возвращается созданная бронь со статусом ``pending``.
     */
    post: operations["create_booking_api_v1_events__event_id__bookings_post"];
  };
  "/api/v1/events/{event_id}/waitlist": {
    /**
     * List Event Waitlist
     * @description Получить лист ожидания для мероприятия.
     *
     * Возвращается список объектов с полями ``id``, ``user_id``, ``position`` и ``created_at``.
     */
    get: operations["list_event_waitlist_api_v1_events__event_id__waitlist_get"];
  };
  "/api/v1/bookings/{booking_id}": {
    /**
     * Get a single booking
     * @description Retrieve a single booking by its ID.
     *
     * Users may only access their own bookings unless they hold an
     * administrative role (super‑administrator or administrator).  If the
     * booking does not exist, a 404 error is returned.
     */
    get: operations["get_booking_endpoint_api_v1_bookings__booking_id__get"];
    /**
     * Update an existing booking
     * @description Modify certain attributes of an existing booking.
     *
     * Only ``group_size`` and ``group_names`` may be updated via this endpoint.
     * Non‑administrative users can update only their own bookings.  Admins
     * (role_id 1 or 2) may update any booking.  A 404 error is returned
     * if the booking does not exist.  If no fields are provided in the
     * request body, the booking is returned unchanged.
     */
    put: operations["update_booking_endpoint_api_v1_bookings__booking_id__put"];
    /**
     * Delete Booking Endpoint
     * @description Удалить бронирование.
     *
     * Доступно только супер‑администраторам и администраторам.  При удалении брони система
     * автоматически пытается заполнить освободившееся место пользователями
     * из листа ожидания.  Возвращает статус ``204 No Content`` в случае
     * успешного удаления.  Если бронирование не найдено, возвращается
     * ошибка 404.
     */
    delete: operations["delete_booking_endpoint_api_v1_bookings__booking_id__delete"];
  };
  "/api/v1/waitlist/{entry_id}": {
    /**
     * Get a waitlist entry
     * @description Retrieve a single waitlist entry by its ID.
     *
     * Only administrators (super‑administrators and administrators) may
     * access detailed waitlist information.  A 404 error is returned if
     * the entry does not exist.
     */
    get: operations["get_waitlist_entry_endpoint_api_v1_waitlist__entry_id__get"];
    /**
     * Update a waitlist entry
     * @description Change the position of a waitlist entry.
     *
     * Accepts a JSON payload specifying the new ``position``.  Only
     * administrators may modify the ordering of the waitlist.  Returns
     * the updated entry on success.  A 404 error is returned if the
     * entry does not exist.
     */
    put: operations["update_waitlist_entry_endpoint_api_v1_waitlist__entry_id__put"];
    /**
     * Delete a waitlist entry
     * @description Remove a waitlist entry.
     *
     * Only administrators may remove users from the waitlist.  When an
     * entry is deleted, the positions of remaining entries are compacted
     * so that the ordering remains continuous.  A 404 error is returned
     * if the entry does not exist.
     */
    delete: operations["delete_waitlist_entry_endpoint_api_v1_waitlist__entry_id__delete"];
  };
  "/api/v1/waitlist/{entry_id}/book": {
    /**
     * Claim a seat from the waitlist
     * @description Confirm a booking from a waitlist notification.
     *
     * When a user receives a notification that a seat has become available,
     * they must call this endpoint to claim the seat.  The service
     * validates that the entry exists, belongs to the current user and
     * that there is at least one seat available.  On success, the
     * waitlist entry is removed, a new booking is created, and the
     * associated notification tasks are marked completed.  If no seats
     * remain or the entry is invalid, an error is returned.
     */
    post: operations["claim_waitlist_seat_api_v1_waitlist__entry_id__book_post"];
  };
  "/api/v1/bookings/{booking_id}/toggle-payment": {
    /**
     * Toggle Booking Payment
     * @description Toggle the payment status of a booking.
     *
     * Only супер‑администраторы и администраторы могут переключать статус оплаты.  The response
     * returns no content on success.
     */
    post: operations["toggle_booking_payment_api_v1_bookings__booking_id__toggle_payment_post"];
  };
  "/api/v1/bookings/{booking_id}/toggle-attendance": {
    /**
     * Toggle Booking Attendance
     * @description Toggle the attendance status of a booking.
     *
     * Only супер‑администраторы и администраторы могут переключать статус посещения.  Returns no content.
     */
    post: operations["toggle_booking_attendance_api_v1_bookings__booking_id__toggle_attendance_post"];
  };
  "/api/v1/settings/": {
    /**
     * List Settings
     * @description List all settings.
     *
     * Only super administrators may read settings.  Future versions may
     * scope settings by namespace and restrict access further.
     */
    get: operations["list_settings_api_v1_settings__get"];
  };
  "/api/v1/settings/{key}": {
    /**
     * Get Setting
     * @description Retrieve a single setting by key.
     *
     * Only super administrators may access individual settings.
     */
    get: operations["get_setting_api_v1_settings__key__get"];
    /**
     * Upsert Setting
     * @description Insert or update a setting.
     *
     * Only super administrators may change settings.  The request body must
     * include ``value`` and ``type`` keys.  Supported types are
     * ``string``, ``int``, ``float`` and ``bool``.
     */
    post: operations["upsert_setting_api_v1_settings__key__post"];
  };
  "/api/v1/messages/": {
    /**
     * List Messages
     * @description List all bot message templates.
     */
    get: operations["list_messages_api_v1_messages__get"];
  };
  "/api/v1/messages/{key}": {
    /**
     * Get Message
     * @description Retrieve a single bot message template by key.
     */
    get: operations["get_message_api_v1_messages__key__get"];
    /**
     * Upsert Message
     * @description Insert or update a bot message template.
     *
     * The request body must contain ``content`` and may contain
     * ``buttons`` (a list of objects).  The ``buttons`` structure
     * should follow the format expected by the client (e.g. callback
     * data for Telegram).
     */
    post: operations["upsert_message_api_v1_messages__key__post"];
    /**
     * Delete Message
     * @description Удалить шаблон сообщения.
     *
     * Только администратор может удалять сообщения.  Возвращает 204
     * при успешном удалении.  Если ключ не найден, возвращается 404.
     */
    delete: operations["delete_message_api_v1_messages__key__delete"];
  };
  "/api/v1/roles/": {
    /**
     * List Roles
     * @description List all roles.
     *
     * Only super administrators (role_id 1) may list roles.
     */
    get: operations["list_roles_api_v1_roles__get"];
    /**
     * Create Role
     * @description Create a new role.
     *
     * Only super administrators may create new roles.  The request body must
     * contain a ``name`` key and may include ``permissions`` (list of strings).
     */
    post: operations["create_role_api_v1_roles__post"];
  };
  "/api/v1/roles/{role_id}": {
    /**
     * Update Role
     * @description Update an existing role.
     *
     * Only super administrators may modify roles.  The body may specify
     * ``name`` and/or ``permissions``.
     */
    put: operations["update_role_api_v1_roles__role_id__put"];
    /**
     * Delete Role
     * @description Delete a role.
     *
     * Only super administrators may delete roles.
     */
    delete: operations["delete_role_api_v1_roles__role_id__delete"];
  };
  "/api/v1/roles/assign": {
    /**
     * Assign Role
     * @description Assign a role to a user.
     *
     * Only super administrators may assign roles to users.  The request body must
     * include ``user_id`` and ``role_id``.
     */
    post: operations["assign_role_api_v1_roles_assign_post"];
  };
  "/api/v1/support/tickets": {
    /**
     * List support tickets
     * @description Return a list of support tickets visible to the current user.
     *
     * Admin users can view all tickets; regular users see only their own.
     * Supports optional filtering by status and pagination via ``limit``
     * and ``offset`` query parameters.
     */
    get: operations["list_tickets_api_v1_support_tickets_get"];
    /**
     * Open a new support ticket
     * @description Create a new support ticket.
     *
     * Accepts the subject and initial message content.  The user must
     * be authenticated.  Returns the created ticket.
     */
    post: operations["create_ticket_api_v1_support_tickets_post"];
  };
  "/api/v1/support/tickets/{ticket_id}": {
    /**
     * Get ticket details and messages
     * @description Retrieve a ticket and all of its messages.
     *
     * Users can access only their own tickets; admins can access any.
     * Returns both the ticket details and the message thread.
     */
    get: operations["get_ticket_api_v1_support_tickets__ticket_id__get"];
    /**
     * Delete a support ticket
     * @description Удалить тикет поддержки.
     *
     * Только администратор может удалять тикеты.  Удаляются также
     * связанные сообщения.  Возвращает 204, если всё прошло успешно.
     */
    delete: operations["delete_ticket_api_v1_support_tickets__ticket_id__delete"];
  };
  "/api/v1/support/tickets/{ticket_id}/reply": {
    /**
     * Reply to a ticket
     * @description Add a reply to an existing support ticket.
     *
     * The current user must be the ticket owner or an admin.
     * Returns the created message.
     */
    post: operations["reply_to_ticket_api_v1_support_tickets__ticket_id__reply_post"];
  };
  "/api/v1/support/tickets/{ticket_id}/status": {
    /**
     * Change ticket status
     * @description Update the status of a support ticket.
     *
     * Only administrators may update the status.  Valid statuses should
     * be validated by the caller (e.g. 'open', 'in_progress', 'resolved',
     * 'closed').
     */
    put: operations["update_ticket_status_api_v1_support_tickets__ticket_id__status_put"];
  };
  "/api/v1/reviews": {
    /**
     * List reviews
     * @description List reviews with optional filters.
     *
     * Regular users see only their own reviews; administrators can
     * filter by event, user or approval status.  Results are
     * paginated.
     */
    get: operations["list_reviews_api_v1_reviews_get"];
    /**
     * Submit a review
     * @description Create a new review for an event.
     *
     * The current user must have attended the event.  Returns the
     * created review with ``approved`` set to ``False``.
     */
    post: operations["create_review_api_v1_reviews_post"];
  };
  "/api/v1/reviews/{review_id}": {
    /**
     * Get a single review
     * @description Retrieve a single review by its ID.
     *
     * Non-admin users can only access their own reviews.
     */
    get: operations["get_review_api_v1_reviews__review_id__get"];
    /**
     * Delete a review
     * @description Удалить отзыв.
     *
     * Только администраторы могут удалить любой отзыв, а обычный
     * пользователь может удалить только свой отзыв.  При отсутствии
     * записи возвращается 404.
     */
    delete: operations["delete_review_api_v1_reviews__review_id__delete"];
  };
  "/api/v1/reviews/{review_id}/moderate": {
    /**
     * Moderate a review
     * @description Approve or reject a review.
     *
     * Only administrators (super‑administrators and administrators) can call this endpoint.
     */
    put: operations["moderate_review_api_v1_reviews__review_id__moderate_put"];
  };
  "/api/v1/mailings/": {
    /**
     * List mailings
     * @description List mailings.
     *
     * Only super administrators may view the list.  Results are paginated.
     */
    get: operations["list_mailings_api_v1_mailings__get"];
    /**
     * Create a mailing
     * @description Create a new mailing.
     *
     * Only super administrators may create mailings.  The ``filters`` field
     * accepts a JSON object specifying criteria (e.g., event_id,
     * is_paid, is_attended) to select recipients.  If
     * ``scheduled_at`` is provided, the mailing may be scheduled for
     * later execution by an external scheduler; immediate sending can
     * be triggered via the send endpoint.
     */
    post: operations["create_mailing_api_v1_mailings__post"];
  };
  "/api/v1/mailings/{mailing_id}": {
    /**
     * Get mailing details
     * @description Retrieve a mailing by ID.
     *
     * Only super administrators may view mailing details.  Raises 404 if the
     * mailing does not exist.
     */
    get: operations["get_mailing_api_v1_mailings__mailing_id__get"];
    /**
     * Update a mailing
     * @description Update an existing mailing.
     *
     * Only super administrators may update mailings.  Any fields omitted from the
     * request body will be left unchanged.  If the ``messengers`` list is
     * provided, the existing messenger list will be replaced and associated
     * tasks will be recreated with the new schedule and channels.
     */
    put: operations["update_mailing_api_v1_mailings__mailing_id__put"];
    /**
     * Delete a mailing
     * @description Удалить рассылку.
     *
     * Only super administrators may delete mailings along with their logs.  Returns
     * 204 on success; raises 404 if the mailing does not exist.
     */
    delete: operations["delete_mailing_api_v1_mailings__mailing_id__delete"];
  };
  "/api/v1/mailings/{mailing_id}/send": {
    /**
     * Execute a mailing
     * @description Send the mailing to all recipients matching its filters.
     *
     * Only super administrators may trigger sending.  Returns the number of
     * recipients to whom the message was sent.
     */
    post: operations["send_mailing_api_v1_mailings__mailing_id__send_post"];
  };
  "/api/v1/mailings/{mailing_id}/logs": {
    /**
     * Get mailing logs
     * @description Retrieve delivery logs for a mailing.
     *
     * Only super administrators may view logs.  Results are paginated.
     */
    get: operations["get_logs_api_v1_mailings__mailing_id__logs_get"];
  };
  "/api/v1/faqs/": {
    /**
     * List Faqs
     * @description Return a paginated list of FAQs.
     *
     * Ordered by ``position`` ascending then ``id`` ascending.  This
     * endpoint is publicly accessible and does not require
     * authentication.  Clients may call it without an Authorization
     * header to retrieve the current FAQ entries.  Administrators
     * should use the CRUD endpoints to manage FAQ content.
     */
    get: operations["list_faqs_api_v1_faqs__get"];
    /**
     * Create Faq
     * @description Create a new FAQ entry (admin only).
     */
    post: operations["create_faq_api_v1_faqs__post"];
  };
  "/api/v1/faqs/{faq_id}": {
    /**
     * Get Faq
     * @description Retrieve a single FAQ by ID.
     *
     * Returns HTTP 404 if the entry is not found.  This endpoint is
     * publicly accessible and does not require authentication.
     */
    get: operations["get_faq_api_v1_faqs__faq_id__get"];
    /**
     * Update Faq
     * @description Update an existing FAQ entry (admin only).
     */
    put: operations["update_faq_api_v1_faqs__faq_id__put"];
    /**
     * Delete Faq
     * @description Delete an FAQ entry (admin only).
     */
    delete: operations["delete_faq_api_v1_faqs__faq_id__delete"];
  };
  "/api/v1/faq/": {
    /**
     * List Faqs
     * @description Return a paginated list of FAQs.
     *
     * Ordered by ``position`` ascending then ``id`` ascending.  This
     * endpoint is publicly accessible and does not require
     * authentication.  Clients may call it without an Authorization
     * header to retrieve the current FAQ entries.  Administrators
     * should use the CRUD endpoints to manage FAQ content.
     */
    get: operations["list_faqs_api_v1_faq__get"];
    /**
     * Create Faq
     * @description Create a new FAQ entry (admin only).
     */
    post: operations["create_faq_api_v1_faq__post"];
  };
  "/api/v1/faq/{faq_id}": {
    /**
     * Get Faq
     * @description Retrieve a single FAQ by ID.
     *
     * Returns HTTP 404 if the entry is not found.  This endpoint is
     * publicly accessible and does not require authentication.
     */
    get: operations["get_faq_api_v1_faq__faq_id__get"];
    /**
     * Update Faq
     * @description Update an existing FAQ entry (admin only).
     */
    put: operations["update_faq_api_v1_faq__faq_id__put"];
    /**
     * Delete Faq
     * @description Delete an FAQ entry (admin only).
     */
    delete: operations["delete_faq_api_v1_faq__faq_id__delete"];
  };
  "/api/v1/info/": {
    /**
     * Get Info
     * @description Return the information message and a list of FAQs.
     *
     * The info message is looked up by the key ``info`` in the
     * ``bot_messages`` table.  The returned object contains the
     * ``content`` and optional ``buttons`` of the info message, along
     * with a list of FAQ short questions and their IDs.  If no info
     * message is configured, a 404 error is returned.
     */
    get: operations["get_info_api_v1_info__get"];
  };
  "/api/v1/statistics/overview": {
    /**
     * Statistics Overview
     * @description Return global counts and revenue statistics (admin only).
     */
    get: operations["statistics_overview_api_v1_statistics_overview_get"];
  };
  "/api/v1/statistics/events": {
    /**
     * Events Statistics
     * @description Return statistics for each event with sorting and pagination (admin only).
     */
    get: operations["events_statistics_api_v1_statistics_events_get"];
  };
  "/api/v1/statistics/payments": {
    /**
     * Payments Statistics
     * @description Return aggregated payment statistics (admin only).
     *
     * Filters payments by optional date range and groups the results by the
     * specified unit.  Only authenticated administrators may access
     * this endpoint.
     */
    get: operations["payments_statistics_api_v1_statistics_payments_get"];
  };
  "/api/v1/statistics/bookings": {
    /**
     * Bookings Statistics
     * @description Return aggregated booking statistics (admin only).
     *
     * Filters bookings by optional date range and groups the results by the
     * specified unit.  Only authenticated administrators may access
     * this endpoint.
     */
    get: operations["bookings_statistics_api_v1_statistics_bookings_get"];
  };
  "/api/v1/statistics/users": {
    /**
     * Users Statistics
     * @description Return aggregated user statistics (admin only).
     *
     * This endpoint provides insight into the user base by aggregating
     * users according to social provider (e.g. Telegram, VK), role
     * (super_admin, admin, user), or by returning overall counts of
     * active and paying users.  Optional date filters limit the
     * activity considered when counting active or paying users.  Only
     * authenticated administrators may access this endpoint.
     */
    get: operations["users_statistics_api_v1_statistics_users_get"];
  };
  "/api/v1/audit/logs": {
    /**
     * List Audit Logs
     * @description Retrieve audit logs with optional filters.
     *
     * Only users with role_id == 1 may access this endpoint.  Returns a
     * list of audit records ordered by timestamp descending.
     */
    get: operations["list_audit_logs_api_v1_audit_logs_get"];
  };
  "/api/v1/tasks": {
    /**
     * Get pending tasks for a messenger
     * @description Return pending tasks for a specific messenger.
     *
     * Bots should poll this endpoint regularly (e.g. every minute) to discover
     * new work items.  Each task corresponds to a scheduled action (currently
     * mailings) and is created separately for each messenger.  When a bot
     * completes a task, it must call the completion endpoint with the task's
     * ID so that the task is not returned again.  Only administrators and
     * bots with an administrator role can access tasks.
     *
     * Parameters
     * ----------
     * messenger : str
     *     Short code of the messenger requesting tasks (e.g. ``telegram``,
     *     ``vk``, ``max``).  Tasks for other messengers are not returned.
     * until : Optional[str]
     *     ISO‑formatted timestamp limiting the maximum ``scheduled_at`` of
     *     tasks returned.  Tasks scheduled after this time are excluded.
     *     If omitted, the current server time is used.
     *
     * Returns
     * -------
     * List[TaskRead]
     *     A list of pending tasks for the given messenger.
     */
    get: operations["get_pending_tasks_api_v1_tasks_get"];
  };
  "/api/v1/tasks/{task_id}/complete": {
    /**
     * Mark a task as completed
     * @description Mark the specified task as completed.
     *
     * Bots must call this endpoint after successfully processing a task returned
     * by ``GET /tasks``.  Once a task is marked as completed it will no
     * longer be returned to any messenger, ensuring that each task is
     * executed at most once per messenger.
     *
     * Parameters
     * ----------
     * task_id : int
     *     Identifier of the task to complete.  This ID is returned by the
     *     ``GET /tasks`` endpoint.
     *
     * Returns
     * -------
     * None
     *     Responds with HTTP 204 No Content on success.
     */
    post: operations["complete_task_api_v1_tasks__task_id__complete_post"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * BookingCreate
     * @description Schema for creating a booking.
     */
    BookingCreate: {
      /**
       * Group Size
       * @default 1
       * @example 1
       */
      group_size?: number;
      /**
       * Group Names
       * @description Names of participants in the group
       */
      group_names?: string[] | null;
    };
    /** BookingRead */
    BookingRead: {
      /** Id */
      id: number;
      /** User Id */
      user_id: number;
      /** Event Id */
      event_id: number;
      /** Group Size */
      group_size: number;
      /** Status */
      status: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Is Paid
       * @default false
       */
      is_paid?: boolean | null;
      /**
       * Is Attended
       * @default false
       */
      is_attended?: boolean | null;
      /** Group Names */
      group_names?: string[] | null;
    };
    /**
     * BookingUpdate
     * @description Schema for updating a booking.
     *
     * Only a subset of booking attributes may be modified by clients.  In
     * particular, ``group_size`` and ``group_names`` can be changed to
     * reflect changes in the size of a party or to provide updated
     * participant names.  Other attributes such as the event identifier,
     * payment status and attendance flags are managed via dedicated
     * endpoints and may not be altered through this model.
     */
    BookingUpdate: {
      /**
       * Group Size
       * @description Updated number of participants in the booking
       */
      group_size?: number | null;
      /**
       * Group Names
       * @description Updated names of participants in the group
       */
      group_names?: string[] | null;
    };
    /**
     * EventCreate
     * @description Schema for creating an event.
     */
    EventCreate: {
      /**
       * Title
       * @example Yoga Class
       */
      title: string;
      /**
       * Description
       * @example A relaxing yoga session
       */
      description?: string | null;
      /**
       * Start Time
       * Format: date-time
       * @example 2025-09-01T10:00:00Z
       */
      start_time: string;
      /**
       * Duration Minutes
       * @example 60
       */
      duration_minutes: number;
      /**
       * Max Participants
       * @example 15
       */
      max_participants: number;
      /**
       * Is Paid
       * @default false
       * @example false
       */
      is_paid?: boolean;
    };
    /**
     * EventDuplicate
     * @description Schema for duplicating an event.
     *
     * Requires a new start time for the duplicated event.  Other fields
     * will be copied from the source event.
     */
    EventDuplicate: {
      /**
       * Start Time
       * Format: date-time
       * @example 2025-09-15T10:00:00Z
       */
      start_time: string;
    };
    /**
     * EventRead
     * @description Schema for reading an event from the API.
     */
    EventRead: {
      /**
       * Title
       * @example Yoga Class
       */
      title: string;
      /**
       * Description
       * @example A relaxing yoga session
       */
      description?: string | null;
      /**
       * Start Time
       * Format: date-time
       * @example 2025-09-01T10:00:00Z
       */
      start_time: string;
      /**
       * Duration Minutes
       * @example 60
       */
      duration_minutes: number;
      /**
       * Max Participants
       * @example 15
       */
      max_participants: number;
      /**
       * Is Paid
       * @default false
       * @example false
       */
      is_paid?: boolean;
      /** Id */
      id: number;
    };
    /**
     * EventUpdate
     * @description Schema for updating an event.
     *
     * All fields are optional; only provided fields will be updated.
     */
    EventUpdate: {
      /** Title */
      title?: string | null;
      /** Description */
      description?: string | null;
      /** Start Time */
      start_time?: string | null;
      /** Duration Minutes */
      duration_minutes?: number | null;
      /** Max Participants */
      max_participants?: number | null;
      /** Is Paid */
      is_paid?: boolean | null;
      /** Price */
      price?: number | null;
    };
    /**
     * FAQCreate
     * @description Schema for creating a new FAQ entry.
     */
    FAQCreate: {
      /**
       * Question Short
       * @description Short question text displayed on the FAQ button
       */
      question_short: string;
      /**
       * Question Full
       * @description Full question text
       */
      question_full?: string | null;
      /**
       * Answer
       * @description Answer text for the FAQ
       */
      answer: string;
      /**
       * Attachments
       * @description List of attachment URLs or identifiers
       */
      attachments?: string[] | null;
      /**
       * Position
       * @description Ordering position for display; lower numbers appear first
       * @default 0
       */
      position?: number | null;
    };
    /**
     * FAQRead
     * @description Schema for reading an FAQ entry.
     */
    FAQRead: {
      /** Id */
      id: number;
      /** Question Short */
      question_short: string;
      /** Question Full */
      question_full: string | null;
      /** Answer */
      answer: string;
      /** Attachments */
      attachments: string[] | null;
      /** Position */
      position: number;
      /** Created At */
      created_at: string;
      /** Updated At */
      updated_at: string;
    };
    /**
     * FAQUpdate
     * @description Schema for updating an existing FAQ entry.
     *
     * All fields are optional; only provided values will be updated.
     */
    FAQUpdate: {
      /** Question Short */
      question_short?: string | null;
      /** Question Full */
      question_full?: string | null;
      /** Answer */
      answer?: string | null;
      /** Attachments */
      attachments?: string[] | null;
      /** Position */
      position?: number | null;
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * MailingCreate
     * @description Schema for creating a new mailing.
     */
    MailingCreate: {
      /**
       * Title
       * @description Title of the mailing for internal reference
       */
      title: string;
      /**
       * Content
       * @description Message content to send to users
       */
      content: string;
      /**
       * Filters
       * @description Criteria to select recipients, e.g. {"event_id": 1, "is_paid": true, "is_attended": true}
       */
      filters?: {
        [key: string]: unknown;
      } | null;
      /**
       * Scheduled At
       * @description When to schedule the mailing; if null, send immediately
       */
      scheduled_at?: string | null;
      /**
       * Messengers
       * @description List of messenger channels to send this mailing to (e.g. ['telegram','vk','max']). If omitted, no tasks will be generated for bots and the mailing will only be stored for record keeping. Supported channels correspond to available bot integrations.
       */
      messengers?: string[] | null;
    };
    /**
     * MailingLogRead
     * @description Schema for reading a single mailing log entry.
     */
    MailingLogRead: {
      /** Id */
      id: number;
      /** Mailing Id */
      mailing_id: number;
      /** User Id */
      user_id: number;
      /** Status */
      status: string;
      /** Error Message */
      error_message: string | null;
      /** Sent At */
      sent_at: string;
    };
    /**
     * MailingRead
     * @description Schema for reading a mailing.
     */
    MailingRead: {
      /** Id */
      id: number;
      /** Created By */
      created_by: number;
      /** Title */
      title: string;
      /** Content */
      content: string;
      /** Filters */
      filters: {
        [key: string]: unknown;
      } | null;
      /** Scheduled At */
      scheduled_at: string | null;
      /** Created At */
      created_at: string;
      /** Messengers */
      messengers: string[] | null;
    };
    /** MailingUpdate */
    MailingUpdate: {
      /** Title */
      title?: string | null;
      /** Content */
      content?: string | null;
      /** Filters */
      filters?: {
        [key: string]: unknown;
      } | null;
      /** Scheduled At */
      scheduled_at?: string | null;
      /** Messengers */
      messengers?: string[] | null;
    };
    /**
     * PaymentCreate
     * @description Schema for creating a payment.
     */
    PaymentCreate: {
      /**
       * Amount
       * @example 1000
       */
      amount: number;
      /**
       * Currency
       * @default RUB
       * @example RUB
       */
      currency?: string;
      /**
       * Description
       * @example Оплата участия в мероприятии
       */
      description?: string | null;
      /**
       * Event Id
       * @description ID мероприятия, если платеж связан с событием
       * @example 1
       */
      event_id?: number | null;
      /**
       * Provider
       * @description Источник платежа: yookassa, support или cash
       * @example yookassa
       */
      provider?: string | null;
    };
    /**
     * PaymentRead
     * @description Schema for reading a payment.
     */
    PaymentRead: {
      /**
       * Amount
       * @example 1000
       */
      amount: number;
      /**
       * Currency
       * @default RUB
       * @example RUB
       */
      currency?: string;
      /**
       * Description
       * @example Оплата участия в мероприятии
       */
      description?: string | null;
      /**
       * Event Id
       * @description ID мероприятия, если платеж связан с событием
       * @example 1
       */
      event_id?: number | null;
      /**
       * Provider
       * @description Источник платежа: yookassa, support или cash
       * @example yookassa
       */
      provider?: string | null;
      /** Id */
      id: number;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Status
       * @example pending
       */
      status?: string | null;
      /**
       * External Id
       * @example 2bcd42fa
       */
      external_id?: string | null;
      /** Confirmed By */
      confirmed_by?: number | null;
      /** Confirmed At */
      confirmed_at?: string | null;
    };
    /**
     * ReviewCreate
     * @description Schema for creating a new review.
     */
    ReviewCreate: {
      /**
       * Event Id
       * @description Identifier of the event being reviewed
       */
      event_id: number;
      /**
       * Rating
       * @description Rating from 1 to 5
       */
      rating: number;
      /**
       * Comment
       * @description Optional textual comment
       */
      comment?: string | null;
    };
    /**
     * ReviewModerate
     * @description Schema for moderating a review.
     */
    ReviewModerate: {
      /**
       * Approved
       * @description Whether to approve the review
       */
      approved: boolean;
    };
    /**
     * ReviewRead
     * @description Schema for reading a review from the API.
     */
    ReviewRead: {
      /** Id */
      id: number;
      /** User Id */
      user_id: number;
      /** Event Id */
      event_id: number;
      /** Rating */
      rating: number;
      /** Comment */
      comment: string | null;
      /** Approved */
      approved: boolean;
      /** Moderated By */
      moderated_by: number | null;
      /** Created At */
      created_at: string;
    };
    /**
     * SocialLogin
     * @description Payload for social login.
     *
     * Clients should provide the external service identifier (e.g. 'telegram',
     * 'vk') and the unique user identifier within that service.  Optionally
     * a full name may be supplied to populate the user record on first login.
     */
    SocialLogin: {
      /** Social Provider */
      social_provider: string;
      /** Social Id */
      social_id: string;
      /** Full Name */
      full_name?: string | null;
    };
    /**
     * SupportMessageCreate
     * @description Schema for creating or replying to a support message.
     *
     * Messages may include text and optional attachments.  Attachments
     * should be provided as a list of strings (e.g. file URLs or IDs);
     * they are stored as JSON in the database.
     */
    SupportMessageCreate: {
      /**
       * Content
       * @description Text content of the message
       */
      content: string;
      /**
       * Attachments
       * @description Optional list of attachment identifiers
       */
      attachments?: string[] | null;
    };
    /**
     * SupportMessageRead
     * @description Schema for reading a support message from the API.
     *
     * Includes the ID, associated ticket, sender role and creation
     * timestamp.  Optionally includes the IDs of the user and admin
     * who sent the message.  The ``content`` field contains the
     * message text with HTML characters escaped to prevent
     * cross‑site scripting.
     */
    SupportMessageRead: {
      /** Id */
      id: number;
      /** Ticket Id */
      ticket_id: number;
      /** Content */
      content: string;
      /** Created At */
      created_at: string;
      /** Sender Role */
      sender_role: string;
      /** User Id */
      user_id?: number | null;
      /** Admin Id */
      admin_id?: number | null;
      /** Attachments */
      attachments?: string[] | null;
    };
    /**
     * SupportTicketCreate
     * @description Schema for creating a new support ticket.
     *
     * The client provides a subject and the initial message content.
     * Additional metadata can be added later (e.g. attachments).
     */
    SupportTicketCreate: {
      /**
       * Subject
       * @description Subject or title of the support request
       */
      subject: string;
      /**
       * Content
       * @description Initial message content
       */
      content: string;
    };
    /**
     * SupportTicketRead
     * @description Schema for reading a support ticket.
     *
     * This schema represents a ticket without its messages.  When
     * retrieving a ticket with messages, the API may return a separate
     * structure containing ``ticket`` and ``messages`` lists.
     */
    SupportTicketRead: {
      /** Id */
      id: number;
      /** User Id */
      user_id: number;
      /** Subject */
      subject: string | null;
      /** Status */
      status: string;
      /** Created At */
      created_at: string;
      /** Updated At */
      updated_at: string;
    };
    /**
     * SupportTicketUpdate
     * @description Schema for updating the status of an existing support ticket.
     *
     * Only the ``status`` field may be updated.  Valid statuses include
     * ``open``, ``in_progress``, ``resolved`` and ``closed``.  Validation
     * of allowed values should be performed at the service or endpoint
     * level.
     */
    SupportTicketUpdate: {
      /**
       * Status
       * @description New status for the ticket
       */
      status: string;
    };
    /**
     * TaskRead
     * @description Schema for a task returned by the tasks API.
     *
     * A task represents some action that an external client (such as a
     * messenger bot) should perform.  Supported types include:
     *
     * * ``"mailing"`` — send a mass mailing; the ``object_id`` points to a row
     *   in the ``mailings`` table, and the ``title``/``description`` provide
     *   context for the bot.
     * * ``"waitlist"`` — notify a user that a seat is available; the
     *   ``object_id`` stores the waitlist entry ID.  Bots should send a
     *   message with a button "Записать" that triggers ``POST /api/v1/waitlist/{entry_id}/book``.
     * * other types may be added in the future (e.g., support ticket alerts).
     *
     * The ``scheduled_at`` field is used for tasks that should not be
     * executed until a particular time (for example, scheduled mailings).
     * For waitlist notifications this value is typically ``None``.
     */
    TaskRead: {
      /** Id */
      id: number;
      /** Type */
      type: string;
      /** Title */
      title?: string | null;
      /** Description */
      description?: string | null;
      /** Scheduled At */
      scheduled_at?: string | null;
    };
    /**
     * TicketWithMessages
     * @description Composite schema for returning a ticket along with its messages.
     */
    TicketWithMessages: {
      ticket: components["schemas"]["SupportTicketRead"];
      /** Messages */
      messages: components["schemas"]["SupportMessageRead"][];
    };
    /**
     * UserCreate
     * @description Schema for registering a user.
     *
     * There are two ways to create a user:
     *
     * * Администратор: требуется ``email`` и ``password``.  ``social_provider`` и
     *   ``social_id`` остаются по умолчанию.
     * * Пользователь из мессенджера: передаются ``social_provider`` и ``social_id``.
     *   ``password`` может быть опущен.
     *
     * Хотя поле ``password`` остаётся необязательным, рекомендуется не отправлять
     * его для пользователей Telegram/соцсетей.  Валидация осуществляется на
     * уровне сервисов.
     */
    UserCreate: {
      /**
       * Email
       * @example user@example.com
       */
      email?: string | null;
      /**
       * Full Name
       * @example Иван Иванов
       */
      full_name?: string | null;
      /**
       * Disabled
       * @default false
       * @example false
       */
      disabled?: boolean;
      /**
       * Password
       * @example strongpassword
       */
      password?: string | null;
      /**
       * Social Provider
       * @description Краткий код социальной сети (telegram, vk, etc.)
       * @example telegram
       */
      social_provider?: string | null;
      /**
       * Social Id
       * @description Идентификатор пользователя в социальной сети
       * @example 123456789
       */
      social_id?: string | null;
    };
    /**
     * UserRead
     * @description Schema for reading a user from the API.
     */
    UserRead: {
      /**
       * Email
       * @example user@example.com
       */
      email?: string | null;
      /**
       * Full Name
       * @example Иван Иванов
       */
      full_name?: string | null;
      /**
       * Disabled
       * @default false
       * @example false
       */
      disabled?: boolean;
      /** Id */
      id: number;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /**
     * WaitlistUpdate
     * @description Schema for updating a waitlist entry.
     *
     * Currently only the position on the waitlist can be modified.  When
     * repositioning an entry, the service will adjust the positions of
     * other entries for the same event to maintain a contiguous ordering.
     */
    WaitlistUpdate: {
      /**
       * Position
       * @description New position for the waitlist entry (1‑based)
       */
      position: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * List Events
   * @description Получить список мероприятий с фильтрами и сортировкой.
   *
   * - **limit**, **offset** — параметры пагинации.
   * - **sort_by** — поле сортировки: `id`, `title`, `start_time`, `duration_minutes`, `max_participants`.
   * - **order** — направление сортировки (`asc`/`desc`).
   * - **is_paid** — фильтр по платности (true/false) или пропущено.
   * - **date_from**, **date_to** — фильтры по дате начала (ISO‑строки).
   */
  list_events_api_v1_events__get: {
    parameters: {
      query?: {
        limit?: number;
        offset?: number;
        sort_by?: string;
        order?: string;
        is_paid?: boolean | null;
        date_from?: string | null;
        date_to?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EventRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Event
   * @description Create a new event.
   *
   * Requires an administrator (role_id 1 or 2).  Validates the
   * authenticated user's role via the ``require_roles`` dependency.
   * Future iterations should perform additional validation on the
   * event payload.
   */
  create_event_api_v1_events__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["EventCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["EventRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Event
   * @description Retrieve a single event by its ID.
   *
   * In the future, add authentication and permission checks (e.g.,
   * private events visible only to certain users).  Raises 404 if
   * the event is not found.
   */
  get_event_api_v1_events__event_id__get: {
    parameters: {
      path: {
        event_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EventRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Event
   * @description Update an existing event.
   *
   * Only administrators (role_id 1 or 2) may modify events.  Partial
   * updates are supported; any unspecified fields remain unchanged.
   */
  update_event_api_v1_events__event_id__put: {
    parameters: {
      path: {
        event_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EventUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EventRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Event
   * @description Delete an event (admin only).
   *
   * When deleting an event, related records (bookings, payments, reviews) are
   * removed as part of the ``EventService.delete_event`` implementation.
   * Future versions should consider soft deletion or additional checks
   * before removing events with dependencies.
   */
  delete_event_api_v1_events__event_id__delete: {
    parameters: {
      path: {
        event_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Duplicate Event
   * @description Duplicate an event with a new start time.
   *
   * Requires administrator privileges (role_id 1 or 2).  The request
   * body must contain the ``start_time`` for the new event.
   */
  duplicate_event_api_v1_events__event_id__duplicate_post: {
    parameters: {
      path: {
        event_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EventDuplicate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["EventRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Event Participants
   * @description List all bookings (participants) for an event.
   *
   * Only administrators (role_id 1 or 2) can view the full participant list.
   * Future versions may allow event organizers or the event creator to
   * access this information.
   */
  list_event_participants_api_v1_events__event_id__participants_get: {
    parameters: {
      path: {
        event_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BookingRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Users
   * @description Получить список всех пользователей.
   *
   * Доступно только супер‑администраторам и администраторам.  В дальнейшем
   * будет добавлена пагинация и фильтрация (по активности, статусу блокировки и т.п.).
   */
  list_users_api_v1_users__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"][];
        };
      };
    };
  };
  /**
   * Register User
   * @description Зарегистрировать нового пользователя.
   *
   * Принимает данные пользователя и возвращает созданную запись.  В
   * будущем здесь будет реализована проверка уникальности e‑mail,
   * хеширование пароля (bcrypt/argon2), подтверждение почты и
   * присвоение роли по умолчанию.  Сейчас данные хранятся в памяти.
   */
  register_user_api_v1_users__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Login User
   * @description Аутентифицировать пользователя и вернуть токен.
   *
   * На входе ожидаются e‑mail и пароль.  В дальнейшем рекомендуется
   * выделить отдельную схему ``UserLogin`` и добавить refresh‑токены
   * для долгосрочной сессии.  Метод будет проверять хешированный
   * пароль и, возможно, блокировать учётные записи после нескольких
   * неудачных попыток.
   */
  login_user_api_v1_users_login_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Social Login
   * @description Authenticate or register a user via social provider and return a token.
   *
   * This endpoint allows bots or messenger integrations to obtain a JWT
   * without requiring an email/password.  If a user with the given
   * ``social_provider`` and ``social_id`` exists, a new access token is issued.
   * Otherwise a new user is created with role ``user`` (role_id=3) and a
   * token is returned.  The optional ``full_name`` is used only when creating
   * a new user.
   */
  social_login_api_v1_users_social_login_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SocialLogin"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update User
   * @description Update a user's profile, status or password.
   *
   * Only administrators may update other users.  The body may
   * contain ``full_name``, ``disabled``, ``password``, or ``role_id``.
   * ``role_id`` changes the user's role via RoleService.
   */
  update_user_api_v1_users__user_id__put: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete User Endpoint
   * @description Удалить пользователя по ID.
   *
   * Только супер‑администратор или администратор может удалять пользователей и не может удалить
   * самого себя.  Удаление первого созданного пользователя (главного
   * администратора) также запрещено.  После удаления пользователя
   * связанные записи (сообщения, тикеты, бронирования, платежи) будут
   * удалены каскадно.
   */
  delete_user_endpoint_api_v1_users__user_id__delete: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Payments
   * @description Получить список платежей.
   *
   * Администратор видит все записи, обычный пользователь — только свои.
   * Поддерживаются фильтры ``event_id``, ``provider`` (yookassa/support/cash), ``status``
   * (pending/success), сортировка по ``created_at`` или ``amount`` и
   * пагинация.
   */
  list_payments_api_v1_payments__get: {
    parameters: {
      query?: {
        event_id?: number | null;
        provider?: string | null;
        status_param?: string | null;
        sort_by?: string | null;
        order?: string | null;
        limit?: number | null;
        offset?: number | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PaymentRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Payment
   * @description Создать новый платёж.
   *
   * Требуется аутентификация.  В будущем будет реализована
   * проверка валидности суммы, интеграция с платежными шлюзами
   * (ЮKassa, Stripe и т.д.), обработка статусов транзакций и
   * связка с конкретным мероприятием или пополнением баланса.
   */
  create_payment_api_v1_payments__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PaymentCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["PaymentRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Confirm Payment
   * @description Подтвердить платёж (администратор или супер‑администратор).
   *
   * Устанавливает статус ``success`` и отмечает подтверждающего.  Для
   * платного мероприятия также помечает связанные брони как оплаченные.
   */
  confirm_payment_api_v1_payments__payment_id__confirm_post: {
    parameters: {
      path: {
        /** @description ID платежа */
        payment_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Payment
   * @description Удалить платёж.
   *
   * Удаление платежей доступно только супер‑администраторам и администраторам.  При
   * необходимости следует запретить удаление подтверждённых платежей;
   * текущая реализация удаляет любую запись.  Возвращает 204 при
   * успешном удалении.
   */
  delete_payment_api_v1_payments__payment_id__delete: {
    parameters: {
      path: {
        /** @description ID платежа */
        payment_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Yookassa Callback
   * @description Обработать callback от ЮKassa.
   *
   * В продуктивной среде ЮKassa отправляет уведомления о статусе
   * платежа.  Здесь представлен только пример структуры: поле
   * ``object.id`` должно содержать ``external_id`` платежа.  На
   * основе этого id в базе обновляется статус платежа.  Отсутствие
   * реальных HTTP‑запросов означает, что эта функция не будет
   * вызываться автоматически в данной среде.
   */
  yookassa_callback_api_v1_payments_yookassa_callback_post: {
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Event Bookings
   * @description Получить список бронирований для мероприятия.
   *
   * Поддерживает сортировку по ``created_at``, ``user_id``, ``is_paid`` или
   * ``is_attended``, направление сортировки, а также пагинацию.
   * Доступна только супер‑администраторам и администраторам.
   */
  list_event_bookings_api_v1_events__event_id__bookings_get: {
    parameters: {
      query?: {
        sort_by?: string | null;
        order?: string | null;
        limit?: number | null;
        offset?: number | null;
      };
      path: {
        /** @description ID of the event */
        event_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BookingRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Booking
   * @description Создать бронь на мероприятие.
   *
   * Если свободных мест нет, пользователь будет помещён в лист ожидания,
   * и возвращается HTTP 400 с описанием.  В противном случае
   * возвращается созданная бронь со статусом ``pending``.
   */
  create_booking_api_v1_events__event_id__bookings_post: {
    parameters: {
      path: {
        /** @description ID of the event to book */
        event_id: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BookingCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["BookingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Event Waitlist
   * @description Получить лист ожидания для мероприятия.
   *
   * Возвращается список объектов с полями ``id``, ``user_id``, ``position`` и ``created_at``.
   */
  list_event_waitlist_api_v1_events__event_id__waitlist_get: {
    parameters: {
      path: {
        /** @description ID of the event */
        event_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get a single booking
   * @description Retrieve a single booking by its ID.
   *
   * Users may only access their own bookings unless they hold an
   * administrative role (super‑administrator or administrator).  If the
   * booking does not exist, a 404 error is returned.
   */
  get_booking_endpoint_api_v1_bookings__booking_id__get: {
    parameters: {
      path: {
        /** @description ID of the booking */
        booking_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BookingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update an existing booking
   * @description Modify certain attributes of an existing booking.
   *
   * Only ``group_size`` and ``group_names`` may be updated via this endpoint.
   * Non‑administrative users can update only their own bookings.  Admins
   * (role_id 1 or 2) may update any booking.  A 404 error is returned
   * if the booking does not exist.  If no fields are provided in the
   * request body, the booking is returned unchanged.
   */
  update_booking_endpoint_api_v1_bookings__booking_id__put: {
    parameters: {
      path: {
        /** @description ID of the booking */
        booking_id: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BookingUpdate"] | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BookingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Booking Endpoint
   * @description Удалить бронирование.
   *
   * Доступно только супер‑администраторам и администраторам.  При удалении брони система
   * автоматически пытается заполнить освободившееся место пользователями
   * из листа ожидания.  Возвращает статус ``204 No Content`` в случае
   * успешного удаления.  Если бронирование не найдено, возвращается
   * ошибка 404.
   */
  delete_booking_endpoint_api_v1_bookings__booking_id__delete: {
    parameters: {
      path: {
        /** @description ID of the booking */
        booking_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get a waitlist entry
   * @description Retrieve a single waitlist entry by its ID.
   *
   * Only administrators (super‑administrators and administrators) may
   * access detailed waitlist information.  A 404 error is returned if
   * the entry does not exist.
   */
  get_waitlist_entry_endpoint_api_v1_waitlist__entry_id__get: {
    parameters: {
      path: {
        /** @description ID of the waitlist entry */
        entry_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update a waitlist entry
   * @description Change the position of a waitlist entry.
   *
   * Accepts a JSON payload specifying the new ``position``.  Only
   * administrators may modify the ordering of the waitlist.  Returns
   * the updated entry on success.  A 404 error is returned if the
   * entry does not exist.
   */
  update_waitlist_entry_endpoint_api_v1_waitlist__entry_id__put: {
    parameters: {
      path: {
        /** @description ID of the waitlist entry */
        entry_id: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WaitlistUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete a waitlist entry
   * @description Remove a waitlist entry.
   *
   * Only administrators may remove users from the waitlist.  When an
   * entry is deleted, the positions of remaining entries are compacted
   * so that the ordering remains continuous.  A 404 error is returned
   * if the entry does not exist.
   */
  delete_waitlist_entry_endpoint_api_v1_waitlist__entry_id__delete: {
    parameters: {
      path: {
        /** @description ID of the waitlist entry */
        entry_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Claim a seat from the waitlist
   * @description Confirm a booking from a waitlist notification.
   *
   * When a user receives a notification that a seat has become available,
   * they must call this endpoint to claim the seat.  The service
   * validates that the entry exists, belongs to the current user and
   * that there is at least one seat available.  On success, the
   * waitlist entry is removed, a new booking is created, and the
   * associated notification tasks are marked completed.  If no seats
   * remain or the entry is invalid, an error is returned.
   */
  claim_waitlist_seat_api_v1_waitlist__entry_id__book_post: {
    parameters: {
      path: {
        /** @description ID of the waitlist entry to claim */
        entry_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["BookingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Toggle Booking Payment
   * @description Toggle the payment status of a booking.
   *
   * Only супер‑администраторы и администраторы могут переключать статус оплаты.  The response
   * returns no content on success.
   */
  toggle_booking_payment_api_v1_bookings__booking_id__toggle_payment_post: {
    parameters: {
      path: {
        /** @description ID of the booking */
        booking_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Toggle Booking Attendance
   * @description Toggle the attendance status of a booking.
   *
   * Only супер‑администраторы и администраторы могут переключать статус посещения.  Returns no content.
   */
  toggle_booking_attendance_api_v1_bookings__booking_id__toggle_attendance_post: {
    parameters: {
      path: {
        /** @description ID of the booking */
        booking_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Settings
   * @description List all settings.
   *
   * Only super administrators may read settings.  Future versions may
   * scope settings by namespace and restrict access further.
   */
  list_settings_api_v1_settings__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
    };
  };
  /**
   * Get Setting
   * @description Retrieve a single setting by key.
   *
   * Only super administrators may access individual settings.
   */
  get_setting_api_v1_settings__key__get: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Upsert Setting
   * @description Insert or update a setting.
   *
   * Only super administrators may change settings.  The request body must
   * include ``value`` and ``type`` keys.  Supported types are
   * ``string``, ``int``, ``float`` and ``bool``.
   */
  upsert_setting_api_v1_settings__key__post: {
    parameters: {
      path: {
        key: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Messages
   * @description List all bot message templates.
   */
  list_messages_api_v1_messages__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
    };
  };
  /**
   * Get Message
   * @description Retrieve a single bot message template by key.
   */
  get_message_api_v1_messages__key__get: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Upsert Message
   * @description Insert or update a bot message template.
   *
   * The request body must contain ``content`` and may contain
   * ``buttons`` (a list of objects).  The ``buttons`` structure
   * should follow the format expected by the client (e.g. callback
   * data for Telegram).
   */
  upsert_message_api_v1_messages__key__post: {
    parameters: {
      path: {
        key: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Message
   * @description Удалить шаблон сообщения.
   *
   * Только администратор может удалять сообщения.  Возвращает 204
   * при успешном удалении.  Если ключ не найден, возвращается 404.
   */
  delete_message_api_v1_messages__key__delete: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Roles
   * @description List all roles.
   *
   * Only super administrators (role_id 1) may list roles.
   */
  list_roles_api_v1_roles__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
    };
  };
  /**
   * Create Role
   * @description Create a new role.
   *
   * Only super administrators may create new roles.  The request body must
   * contain a ``name`` key and may include ``permissions`` (list of strings).
   */
  create_role_api_v1_roles__post: {
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Role
   * @description Update an existing role.
   *
   * Only super administrators may modify roles.  The body may specify
   * ``name`` and/or ``permissions``.
   */
  update_role_api_v1_roles__role_id__put: {
    parameters: {
      path: {
        role_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Role
   * @description Delete a role.
   *
   * Only super administrators may delete roles.
   */
  delete_role_api_v1_roles__role_id__delete: {
    parameters: {
      path: {
        role_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Assign Role
   * @description Assign a role to a user.
   *
   * Only super administrators may assign roles to users.  The request body must
   * include ``user_id`` and ``role_id``.
   */
  assign_role_api_v1_roles_assign_post: {
    requestBody: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List support tickets
   * @description Return a list of support tickets visible to the current user.
   *
   * Admin users can view all tickets; regular users see only their own.
   * Supports optional filtering by status and pagination via ``limit``
   * and ``offset`` query parameters.
   */
  list_tickets_api_v1_support_tickets_get: {
    parameters: {
      query?: {
        status?: string | null;
        limit?: number;
        offset?: number;
        /** @description Sort by 'created_at', 'updated_at' or 'status' */
        sort_by?: string | null;
        /** @description Sort order 'asc' or 'desc' */
        order?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SupportTicketRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Open a new support ticket
   * @description Create a new support ticket.
   *
   * Accepts the subject and initial message content.  The user must
   * be authenticated.  Returns the created ticket.
   */
  create_ticket_api_v1_support_tickets_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SupportTicketCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["SupportTicketRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get ticket details and messages
   * @description Retrieve a ticket and all of its messages.
   *
   * Users can access only their own tickets; admins can access any.
   * Returns both the ticket details and the message thread.
   */
  get_ticket_api_v1_support_tickets__ticket_id__get: {
    parameters: {
      path: {
        ticket_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TicketWithMessages"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete a support ticket
   * @description Удалить тикет поддержки.
   *
   * Только администратор может удалять тикеты.  Удаляются также
   * связанные сообщения.  Возвращает 204, если всё прошло успешно.
   */
  delete_ticket_api_v1_support_tickets__ticket_id__delete: {
    parameters: {
      path: {
        ticket_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Reply to a ticket
   * @description Add a reply to an existing support ticket.
   *
   * The current user must be the ticket owner or an admin.
   * Returns the created message.
   */
  reply_to_ticket_api_v1_support_tickets__ticket_id__reply_post: {
    parameters: {
      path: {
        ticket_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SupportMessageCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["SupportMessageRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Change ticket status
   * @description Update the status of a support ticket.
   *
   * Only administrators may update the status.  Valid statuses should
   * be validated by the caller (e.g. 'open', 'in_progress', 'resolved',
   * 'closed').
   */
  update_ticket_status_api_v1_support_tickets__ticket_id__status_put: {
    parameters: {
      path: {
        ticket_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SupportTicketUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SupportTicketRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List reviews
   * @description List reviews with optional filters.
   *
   * Regular users see only their own reviews; administrators can
   * filter by event, user or approval status.  Results are
   * paginated.
   */
  list_reviews_api_v1_reviews_get: {
    parameters: {
      query?: {
        event_id?: number | null;
        user_id?: number | null;
        approved?: boolean | null;
        limit?: number;
        offset?: number;
        /** @description Sort by 'created_at' or 'rating' */
        sort_by?: string | null;
        /** @description Sort order 'asc' or 'desc' */
        order?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Submit a review
   * @description Create a new review for an event.
   *
   * The current user must have attended the event.  Returns the
   * created review with ``approved`` set to ``False``.
   */
  create_review_api_v1_reviews_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReviewCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["ReviewRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get a single review
   * @description Retrieve a single review by its ID.
   *
   * Non-admin users can only access their own reviews.
   */
  get_review_api_v1_reviews__review_id__get: {
    parameters: {
      path: {
        review_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete a review
   * @description Удалить отзыв.
   *
   * Только администраторы могут удалить любой отзыв, а обычный
   * пользователь может удалить только свой отзыв.  При отсутствии
   * записи возвращается 404.
   */
  delete_review_api_v1_reviews__review_id__delete: {
    parameters: {
      path: {
        review_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Moderate a review
   * @description Approve or reject a review.
   *
   * Only administrators (super‑administrators and administrators) can call this endpoint.
   */
  moderate_review_api_v1_reviews__review_id__moderate_put: {
    parameters: {
      path: {
        review_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReviewModerate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List mailings
   * @description List mailings.
   *
   * Only super administrators may view the list.  Results are paginated.
   */
  list_mailings_api_v1_mailings__get: {
    parameters: {
      query?: {
        limit?: number;
        offset?: number;
        /** @description Sort by 'created_at' or 'scheduled_at' */
        sort_by?: string | null;
        /** @description Sort order 'asc' or 'desc' */
        order?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MailingRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create a mailing
   * @description Create a new mailing.
   *
   * Only super administrators may create mailings.  The ``filters`` field
   * accepts a JSON object specifying criteria (e.g., event_id,
   * is_paid, is_attended) to select recipients.  If
   * ``scheduled_at`` is provided, the mailing may be scheduled for
   * later execution by an external scheduler; immediate sending can
   * be triggered via the send endpoint.
   */
  create_mailing_api_v1_mailings__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["MailingCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["MailingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get mailing details
   * @description Retrieve a mailing by ID.
   *
   * Only super administrators may view mailing details.  Raises 404 if the
   * mailing does not exist.
   */
  get_mailing_api_v1_mailings__mailing_id__get: {
    parameters: {
      path: {
        mailing_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MailingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update a mailing
   * @description Update an existing mailing.
   *
   * Only super administrators may update mailings.  Any fields omitted from the
   * request body will be left unchanged.  If the ``messengers`` list is
   * provided, the existing messenger list will be replaced and associated
   * tasks will be recreated with the new schedule and channels.
   */
  update_mailing_api_v1_mailings__mailing_id__put: {
    parameters: {
      path: {
        mailing_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MailingUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MailingRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete a mailing
   * @description Удалить рассылку.
   *
   * Only super administrators may delete mailings along with their logs.  Returns
   * 204 on success; raises 404 if the mailing does not exist.
   */
  delete_mailing_api_v1_mailings__mailing_id__delete: {
    parameters: {
      path: {
        mailing_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Execute a mailing
   * @description Send the mailing to all recipients matching its filters.
   *
   * Only super administrators may trigger sending.  Returns the number of
   * recipients to whom the message was sent.
   */
  send_mailing_api_v1_mailings__mailing_id__send_post: {
    parameters: {
      path: {
        mailing_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": number;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get mailing logs
   * @description Retrieve delivery logs for a mailing.
   *
   * Only super administrators may view logs.  Results are paginated.
   */
  get_logs_api_v1_mailings__mailing_id__logs_get: {
    parameters: {
      query?: {
        limit?: number;
        offset?: number;
      };
      path: {
        mailing_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MailingLogRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Faqs
   * @description Return a paginated list of FAQs.
   *
   * Ordered by ``position`` ascending then ``id`` ascending.  This
   * endpoint is publicly accessible and does not require
   * authentication.  Clients may call it without an Authorization
   * header to retrieve the current FAQ entries.  Administrators
   * should use the CRUD endpoints to manage FAQ content.
   */
  list_faqs_api_v1_faqs__get: {
    parameters: {
      query?: {
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FAQRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Faq
   * @description Create a new FAQ entry (admin only).
   */
  create_faq_api_v1_faqs__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FAQCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["FAQRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Faq
   * @description Retrieve a single FAQ by ID.
   *
   * Returns HTTP 404 if the entry is not found.  This endpoint is
   * publicly accessible and does not require authentication.
   */
  get_faq_api_v1_faqs__faq_id__get: {
    parameters: {
      path: {
        faq_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FAQRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Faq
   * @description Update an existing FAQ entry (admin only).
   */
  update_faq_api_v1_faqs__faq_id__put: {
    parameters: {
      path: {
        faq_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FAQUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FAQRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Faq
   * @description Delete an FAQ entry (admin only).
   */
  delete_faq_api_v1_faqs__faq_id__delete: {
    parameters: {
      path: {
        faq_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Faqs
   * @description Return a paginated list of FAQs.
   *
   * Ordered by ``position`` ascending then ``id`` ascending.  This
   * endpoint is publicly accessible and does not require
   * authentication.  Clients may call it without an Authorization
   * header to retrieve the current FAQ entries.  Administrators
   * should use the CRUD endpoints to manage FAQ content.
   */
  list_faqs_api_v1_faq__get: {
    parameters: {
      query?: {
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FAQRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Faq
   * @description Create a new FAQ entry (admin only).
   */
  create_faq_api_v1_faq__post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FAQCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["FAQRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Faq
   * @description Retrieve a single FAQ by ID.
   *
   * Returns HTTP 404 if the entry is not found.  This endpoint is
   * publicly accessible and does not require authentication.
   */
  get_faq_api_v1_faq__faq_id__get: {
    parameters: {
      path: {
        faq_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FAQRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Faq
   * @description Update an existing FAQ entry (admin only).
   */
  update_faq_api_v1_faq__faq_id__put: {
    parameters: {
      path: {
        faq_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FAQUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FAQRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Faq
   * @description Delete an FAQ entry (admin only).
   */
  delete_faq_api_v1_faq__faq_id__delete: {
    parameters: {
      path: {
        faq_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Info
   * @description Return the information message and a list of FAQs.
   *
   * The info message is looked up by the key ``info`` in the
   * ``bot_messages`` table.  The returned object contains the
   * ``content`` and optional ``buttons`` of the info message, along
   * with a list of FAQ short questions and their IDs.  If no info
   * message is configured, a 404 error is returned.
   */
  get_info_api_v1_info__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
    };
  };
  /**
   * Statistics Overview
   * @description Return global counts and revenue statistics (admin only).
   */
  statistics_overview_api_v1_statistics_overview_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
    };
  };
  /**
   * Events Statistics
   * @description Return statistics for each event with sorting and pagination (admin only).
   */
  events_statistics_api_v1_statistics_events_get: {
    parameters: {
      query?: {
        sort_by?: string;
        order?: string;
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Payments Statistics
   * @description Return aggregated payment statistics (admin only).
   *
   * Filters payments by optional date range and groups the results by the
   * specified unit.  Only authenticated administrators may access
   * this endpoint.
   */
  payments_statistics_api_v1_statistics_payments_get: {
    parameters: {
      query?: {
        /** @description ISO date (YYYY-MM-DD). Include payments created on or after this date. */
        start_date?: string | null;
        /** @description ISO date (YYYY-MM-DD). Include payments created before this date. */
        end_date?: string | null;
        /** @description Aggregation unit: day, month, event, provider, status */
        group_by?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Bookings Statistics
   * @description Return aggregated booking statistics (admin only).
   *
   * Filters bookings by optional date range and groups the results by the
   * specified unit.  Only authenticated administrators may access
   * this endpoint.
   */
  bookings_statistics_api_v1_statistics_bookings_get: {
    parameters: {
      query?: {
        /** @description ISO date (YYYY-MM-DD). Include bookings created on or after this date. */
        start_date?: string | null;
        /** @description ISO date (YYYY-MM-DD). Include bookings created before this date. */
        end_date?: string | null;
        /** @description Aggregation unit: day, month, event, status */
        group_by?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Users Statistics
   * @description Return aggregated user statistics (admin only).
   *
   * This endpoint provides insight into the user base by aggregating
   * users according to social provider (e.g. Telegram, VK), role
   * (super_admin, admin, user), or by returning overall counts of
   * active and paying users.  Optional date filters limit the
   * activity considered when counting active or paying users.  Only
   * authenticated administrators may access this endpoint.
   */
  users_statistics_api_v1_statistics_users_get: {
    parameters: {
      query?: {
        /** @description ISO date (YYYY-MM-DD). Consider activity on or after this date when computing active and paying users. */
        start_date?: string | null;
        /** @description ISO date (YYYY-MM-DD). Consider activity before this date when computing active and paying users. */
        end_date?: string | null;
        /** @description Aggregation unit: social_provider, role or none (overall metrics) */
        group_by?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Audit Logs
   * @description Retrieve audit logs with optional filters.
   *
   * Only users with role_id == 1 may access this endpoint.  Returns a
   * list of audit records ordered by timestamp descending.
   */
  list_audit_logs_api_v1_audit_logs_get: {
    parameters: {
      query?: {
        /** @description Filter by acting user ID */
        user_id?: number | null;
        /** @description Filter by object type (event, booking, payment, etc.) */
        object_type?: string | null;
        /** @description Filter by action (create, update, delete) */
        action?: string | null;
        /** @description Start date (ISO format) for filtering */
        start_date?: string | null;
        /** @description End date (ISO format) for filtering */
        end_date?: string | null;
        /** @description Maximum number of logs to return */
        limit?: number;
        /** @description Number of logs to skip */
        offset?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
              [key: string]: unknown;
            }[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get pending tasks for a messenger
   * @description Return pending tasks for a specific messenger.
   *
   * Bots should poll this endpoint regularly (e.g. every minute) to discover
   * new work items.  Each task corresponds to a scheduled action (currently
   * mailings) and is created separately for each messenger.  When a bot
   * completes a task, it must call the completion endpoint with the task's
   * ID so that the task is not returned again.  Only administrators and
   * bots with an administrator role can access tasks.
   *
   * Parameters
   * ----------
   * messenger : str
   *     Short code of the messenger requesting tasks (e.g. ``telegram``,
   *     ``vk``, ``max``).  Tasks for other messengers are not returned.
   * until : Optional[str]
   *     ISO‑formatted timestamp limiting the maximum ``scheduled_at`` of
   *     tasks returned.  Tasks scheduled after this time are excluded.
   *     If omitted, the current server time is used.
   *
   * Returns
   * -------
   * List[TaskRead]
   *     A list of pending tasks for the given messenger.
   */
  get_pending_tasks_api_v1_tasks_get: {
    parameters: {
      query: {
        /** @description Code of the messenger requesting tasks. Supported values: 'telegram', 'vk', 'max'. Only tasks for this messenger will be returned. */
        messenger: string;
        /** @description Optional ISO date/time up to which tasks should be returned. Tasks scheduled after this time are excluded. If omitted, the current server time is used. */
        until?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TaskRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Mark a task as completed
   * @description Mark the specified task as completed.
   *
   * Bots must call this endpoint after successfully processing a task returned
   * by ``GET /tasks``.  Once a task is marked as completed it will no
   * longer be returned to any messenger, ensuring that each task is
   * executed at most once per messenger.
   *
   * Parameters
   * ----------
   * task_id : int
   *     Identifier of the task to complete.  This ID is returned by the
   *     ``GET /tasks`` endpoint.
   *
   * Returns
   * -------
   * None
   *     Responds with HTTP 204 No Content on success.
   */
  complete_task_api_v1_tasks__task_id__complete_post: {
    parameters: {
      path: {
        task_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
}
